* Data Structures:

** The tracks:

   The following:

#+BEGIN_SRC clojure
  (def tracks
    [{:x 2 :y 0 :track-piece :fs}
     {:x 3 :y 0 :track-piece :horiz}
     {:x 0 :y 1 :track-piece :fs}
     {:x 1 :y 1 :track-piece :horiz}
     {:x 2 :y 1 :track-piece :int}
     {:x 3 :y 1 :track-piece :horiz}
     {:x 0 :y 2 :track-piece :vert}
     {:x 2 :y 2 :track-piece :vert}])
#+END_SRC

describes the following visual tracks:

#+BEGIN_SRC text
 0123
0  /-
1/-+-
2| |
#+END_SRC

** carts:

#+BEGIN_SRC clojure
  (def carts
    [{:x 3 :y 2 :dir :up :last-turn :left}
     {:x 2 :y 1 :dir :right :last-turn :straight}])
#+END_SRC

* Functions breakdown

** cart-next-state
:in: a cart, {:x 3 :y 2 :dir :up :last-turn :straight}
:in: tracks, (see above)
:processing: based on the carts current location, direction, last
turn, and the track(s) it is on, calculate its next
coord/dir/last-turn. 
:out: {:x 4 :y 1 :dir :right :last-turn :right} 

** get-track-segment
:in: tracks
:in: a coordinate
:out: what the track piece under that coordinate is.  One of: 
#{:horiz :vert :bs (backslash) :fs (forwardslash)}

** parse-input
:in: a file where each line is composed of the symbols: | - / \ + < >
^ v.
:out: a data structure like:

#+BEGIN_SRC clojure
  (def tracks-n-carts 
    [{:x 1 :y 3 :symbol :inter}
     {:x 1 :y 2 :symbol :vert}])
#+END_SRC

~:symbol~ can be any of:

|-/\+v^<>

** make-tracks
:in: tracks-n-carts (see above)
:processing: We need to separate the tracks from the carts because the
carts obscure what is under them for example:

#+BEGIN_SRC text
 0123
0/->-
#+END_SRC

Needs to be converted to just tracks, i.e. with the cart effectively
not present:

#+BEGIN_SRC text
 0123
0/---
#+END_SRC

or as a data structure:
#+BEGIN_SRC clojure
  (def tracks
    [{:x 0 :y 0 :track :fs}
     {:x 1 :y 0 :track :horiz}
     {:x 2 :y 0 :track :horiz}
     {:x 3 :y 0 :track :horiz}])
#+END_SRC
:out: the tracks data structure

** make-carts
:in: tracks-n-carts
:processing: extract list of all carts & directions.
:out: carts
